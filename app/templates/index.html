<!DOCTYPE html>
<html>
<head>
    <title>Wanderlog Map</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@100;200;300&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root { --app-font-family: 'Poppins', 'Verdana', sans-serif; }
        body, html { height: 100%; font-family: var(--app-font-family); overflow: hidden; }
        button, input, select { font-family: inherit; }
        #map-container { position: relative; width: 100vw; height: 100vh; }
        #map { width: 100%; height: 100%; }
        .menu-container { position: absolute; top: 0; right: 0; height: 100%; width: min(340px, 90vw); z-index: 1000; background-color: rgba(255,255,255,0.96); padding: 24px 24px 24px 16px; border-radius: 24px 0 0 24px; box-shadow: -8px 0 24px rgba(0,0,0,0.18); display: flex; flex-direction: column; gap: 16px; transform: translateX(calc(100% - 80px)); transition: transform 0.35s ease, box-shadow 0.35s ease, padding 0.35s ease; backdrop-filter: blur(14px); overflow: hidden; }
        .menu-container.open { transform: translateX(0); box-shadow: -12px 0 32px rgba(0,0,0,0.25); padding-left: 24px; }
        .menu-toggle { align-self: flex-start; cursor: pointer; user-select: none; padding: 18px 12px; background: rgba(255,255,255,0.95); border-radius: 18px; box-shadow: 0 6px 18px rgba(0,0,0,0.12); transition: background 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease; border: none; display: inline-flex; flex-direction: column; align-items: center; justify-content: center; gap: 8px; text-transform: uppercase; letter-spacing: 0.12em; color: #333; writing-mode: vertical-rl; text-orientation: mixed; font-weight: 600; }
        .menu-toggle:hover { background: rgba(255,255,255,1); transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,0,0,0.25); }
        .menu-toggle:focus { outline: 2px solid rgba(0,120,212,0.6); outline-offset: 2px; }
        .menu-toggle .menu-toggle-icon { font-size: 20px; line-height: 1; }
        .menu-toggle .menu-toggle-text { font-size: 12px; }
        .menu-container.open .menu-toggle { align-self: flex-end; margin-left: auto; writing-mode: horizontal-tb; flex-direction: row; padding: 10px 16px; border-radius: 14px; gap: 8px; letter-spacing: 0.08em; box-shadow: 0 4px 14px rgba(0,0,0,0.15); }
        .menu-container.open .menu-toggle .menu-toggle-text { font-size: 14px; }
        .overlay-controls { display: flex; flex-direction: column; gap: 12px; opacity: 0; transform: translateX(16px); transition: opacity 0.25s ease 0.1s, transform 0.25s ease 0.1s; overflow-y: auto; max-height: calc(100% - 80px); padding-right: 4px; pointer-events: none; }
        .menu-container.open .overlay-controls { opacity: 1; transform: translateX(0); pointer-events: auto; }
        .overlay-button { background: rgba(255,255,255,0.95); color: #333; border: none; padding: 12px 18px; font-size: 14px; font-weight: 600; border-radius: 15px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.15); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2); min-width: 180px; text-align: center; width: 100%; }
        .overlay-button:hover { background: rgba(255,255,255,1); transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,0,0,0.25); }
        .overlay-button:active { transform: translateY(0); box-shadow: 0 2px 10px rgba(0,0,0,0.2); }
        .checkbox-group { display: flex; flex-direction: column; gap: 4px; }
        .checkbox-group label { display: flex; align-items: center; gap: 4px; font-size: 14px; }
        .overlay-button.primary { color: black; }
        .overlay-button.primary:hover { background: rgb(214,214,214); }
        #status { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(255,255,255,0.9); padding: 8px 12px; border-radius: 4px; display: none; font-size: 14px; z-index: 1000; }
        #status.success { border: 1px solid #4CAF50; color: #4CAF50; }
        #status.error { border: 1px solid #F44336; color: #F44336; }
        .loading-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.8); display: none; align-items: center; justify-content: center; z-index: 2000; }
        .loading-spinner { text-align: center; font-size: 18px; }
        .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #0078D7; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .modal-overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.45); display: none; align-items: center; justify-content: center; z-index: 3000; padding: 20px; }
        .modal-overlay.open { display: flex; }
        .modal-content { background: #fff; border-radius: 12px; width: min(420px, 100%); box-shadow: 0 12px 32px rgba(0,0,0,0.25); padding: 24px; display: flex; flex-direction: column; gap: 16px; outline: none; }
        .modal-content h2 { font-size: 20px; margin-bottom: 4px; }
        .modal-content form { display: flex; flex-direction: column; gap: 14px; }
        .form-group { display: flex; flex-direction: column; gap: 6px; }
        .form-group label { font-weight: 600; font-size: 14px; color: #333; }
        .form-group input, .form-group select { padding: 10px; border: 1px solid #ccc; border-radius: 8px; font-size: 14px; width: 100%; }
        .modal-actions { display: flex; justify-content: flex-end; gap: 12px; margin-top: 8px; }
        .modal-button { border: none; border-radius: 8px; padding: 10px 18px; font-size: 14px; cursor: pointer; transition: background 0.2s ease, transform 0.2s ease; font-weight: 600; }
        .modal-button.secondary { background: #e0e0e0; color: #333; }
        .modal-button.secondary:hover { background: #d5d5d5; }
        .modal-button.primary { background: #0078d4; color: #fff; }
        .modal-button.primary:hover { background: #0062ad; transform: translateY(-1px); }
        .modal-button:focus { outline: 2px solid #0078d4; outline-offset: 2px; }
    </style>
</head>
<body>
<div id="map-container">
    <div id="map"></div>
    <input type="file" id="timelineFile" accept=".json" style="display:none" onchange="updateMap()">
    <div class="menu-container" role="complementary" aria-label="Map controls panel">
        <button class="menu-toggle" type="button" onclick="toggleMenu()" aria-label="Open menu" aria-expanded="false" aria-controls="menuControls">
            <span class="menu-toggle-icon" aria-hidden="true">‚ò∞</span>
            <span class="menu-toggle-text">Menu</span>
        </button>
        <div class="overlay-controls" id="menuControls" aria-hidden="true" inert>
            <button class="overlay-button primary" onclick="document.getElementById('timelineFile').click()">üìç Import Google Timeline Data</button>
            <button class="overlay-button" onclick="clearMap()">üóëÔ∏è Clear ALL Timeline Data</button>
            <button class="overlay-button" onclick="addManualPoint()">‚ûï Add Data Point</button>
            <div id="sourceTypeFilters" class="checkbox-group"></div>
            <button class="overlay-button" onclick="refreshMap()">üîÑ Refresh Map</button>
        </div>
    </div>
    <div id="status"></div>
    <div class="loading-overlay" id="loading">
        <div class="loading-spinner">
            <div class="spinner"></div>
            <div>Loading...</div>
        </div>
    </div>
    <div id="manualPointModal" class="modal-overlay" aria-hidden="true" hidden>
        <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="manualPointTitle" tabindex="-1">
            <h2 id="manualPointTitle">Add Data Point</h2>
            <form id="manualPointForm">
                <div class="form-group">
                    <label for="manualPlace">Place Name</label>
                    <input type="text" id="manualPlace" name="place_name" autocomplete="off" required>
                </div>
                <div class="form-group">
                    <label for="manualDate">Date</label>
                    <input type="date" id="manualDate" name="start_date" required>
                </div>
                <div class="form-group">
                    <label for="manualLatitude">Latitude</label>
                    <input type="number" id="manualLatitude" name="latitude" step="any" required>
                </div>
                <div class="form-group">
                    <label for="manualLongitude">Longitude</label>
                    <input type="number" id="manualLongitude" name="longitude" step="any" required>
                </div>
                <div class="modal-actions">
                    <button type="button" class="modal-button secondary" id="manualPointCancel">Cancel</button>
                    <button type="submit" class="modal-button primary">Save</button>
                </div>
            </form>
        </div>
    </div>
</div>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
<script>
const MAPBOX_TOKEN = "{{ mapbox_token }}";
let map;
let markerCluster;
let manualPointModal;
let manualPointModalContent;
let manualPointForm;
let manualPointCancelButton;
let manualPointFocusableElements = [];
let previouslyFocusedElement = null;
let manualPointModalInitialized = false;

function showLoading() { document.getElementById('loading').style.display = 'flex'; }
function hideLoading() { document.getElementById('loading').style.display = 'none'; }
function showStatus(message, isError=false) {
    const status = document.getElementById('status');
    status.textContent = message;
    status.className = isError ? 'error' : 'success';
    status.style.display = 'block';
    setTimeout(() => status.style.display = 'none', 4000);
}

function initMap() {
    // Create a Leaflet map centered on a default view
    map = L.map('map').setView([40.65997395108914, -73.71300111746832], 5);
    // Add Mapbox tiles using the token passed from the backend
    L.tileLayer(`https://api.mapbox.com/styles/v1/mapbox/outdoors-v12/tiles/{z}/{x}/{y}?access_token=${MAPBOX_TOKEN}`, {
        maxZoom: 18,
        attribution: 'Mapbox'
    }).addTo(map);
    // Cluster group keeps the map responsive when many markers are shown
    markerCluster = L.markerClusterGroup();
    map.addLayer(markerCluster);
    // Load existing markers once the map is ready
    loadMarkers();
}

async function loadMarkers() {
    // Show a loading overlay while fetching marker data
    showLoading();
    // Remove any markers currently displayed
    markerCluster.clearLayers();
    // Collect the values of all checked source type filters
    const checked = Array.from(
        document.querySelectorAll('#sourceTypeFilters input:checked')
    ).map(cb => cb.value);
    try {
        // Request the marker list from the server, filtering by source type
        const response = await fetch('/api/map_data', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ source_types: checked })
        });
        // Parse the JSON response
        const markers = await response.json();
        // Add a Leaflet marker for each item returned
        markers.forEach(m => {
            const popup = `<div><strong>Place Name:</strong> ${m.place}<br>` +
                          `<strong>Date Visited:</strong> ${m.date}<br>` +
                          `<strong>Coordinates:</strong> ${m.lat.toFixed(4)}, ${m.lng.toFixed(4)}</div>`;
            L.marker([m.lat, m.lng]).bindPopup(popup).addTo(markerCluster);
        });
        // Done loading
        hideLoading();
    } catch(err) {
        hideLoading();
        console.error(err);
    }
}

async function updateMap() {
    const fileInput = document.getElementById('timelineFile');
    if (!fileInput.files.length) { showStatus('No file selected!', true); return; }
    showLoading();
    const formData = new FormData();
    formData.append('file', fileInput.files[0]);
    try {
        const response = await fetch('/api/update_timeline', { method: 'POST', body: formData });
        const result = await response.json();
        hideLoading();
        showStatus(result.message, result.status === 'error');
        if (result.status === 'success') { loadMarkers(); }
    } catch(err) {
        hideLoading();
        showStatus('Error: ' + err.message, true);
    }
}

async function clearMap() {
    showLoading();
    try {
        const response = await fetch('/api/clear', { method: 'POST' });
        const result = await response.json();
        hideLoading();
        showStatus(result.message, result.status === 'error');
        if (result.status === 'success') { loadMarkers(); }
    } catch(error) {
        hideLoading();
        showStatus('Error: ' + error.message, true);
    }
}

function setupManualPointModal() {
    if (manualPointModalInitialized) { return; }
    manualPointModal = document.getElementById('manualPointModal');
    if (!manualPointModal) { return; }
    manualPointModalContent = manualPointModal.querySelector('.modal-content');
    manualPointForm = document.getElementById('manualPointForm');
    manualPointCancelButton = document.getElementById('manualPointCancel');

    if (manualPointForm) {
        manualPointForm.addEventListener('submit', handleManualPointSubmit);
    }

    if (manualPointCancelButton) {
        manualPointCancelButton.addEventListener('click', (event) => {
            event.preventDefault();
            closeManualPointModal();
        });
    }

    if (manualPointModal) {
        manualPointModal.addEventListener('click', (event) => {
            if (event.target === manualPointModal) {
                closeManualPointModal();
            }
        });
    }

    manualPointModalInitialized = true;
}

function setManualPointFocusableElements() {
    if (!manualPointModal) {
        manualPointFocusableElements = [];
        return;
    }
    manualPointFocusableElements = Array.from(
        manualPointModal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')
    ).filter(el => !el.disabled);
}

function manualPointKeydownHandler(event) {
    if (!manualPointModal || !manualPointModal.classList.contains('open')) { return; }

    if (event.key === 'Escape') {
        event.preventDefault();
        closeManualPointModal();
        return;
    }

    if (event.key !== 'Tab') { return; }

    setManualPointFocusableElements();
    if (manualPointFocusableElements.length === 0) {
        event.preventDefault();
        if (manualPointModalContent) { manualPointModalContent.focus(); }
        return;
    }

    const firstFocusable = manualPointFocusableElements[0];
    const lastFocusable = manualPointFocusableElements[manualPointFocusableElements.length - 1];
    const activeElement = document.activeElement;

    if (event.shiftKey) {
        if (activeElement === firstFocusable || !manualPointModal.contains(activeElement)) {
            event.preventDefault();
            lastFocusable.focus();
        }
    } else if (activeElement === lastFocusable) {
        event.preventDefault();
        firstFocusable.focus();
    }
}

function openManualPointModal() {
    if (!manualPointModal) { setupManualPointModal(); }
    if (!manualPointModal) { return; }

    previouslyFocusedElement = document.activeElement;
    manualPointModal.classList.add('open');
    manualPointModal.removeAttribute('hidden');
    manualPointModal.setAttribute('aria-hidden', 'false');

    setManualPointFocusableElements();
    const placeField = manualPointForm ? manualPointForm.elements['place_name'] : null;
    if (placeField) {
        placeField.focus();
    } else if (manualPointFocusableElements.length) {
        manualPointFocusableElements[0].focus();
    } else if (manualPointModalContent) {
        manualPointModalContent.focus();
    }

    document.addEventListener('keydown', manualPointKeydownHandler);
}

function closeManualPointModal() {
    if (!manualPointModal) { return; }

    manualPointModal.classList.remove('open');
    manualPointModal.setAttribute('aria-hidden', 'true');
    manualPointModal.setAttribute('hidden', '');
    manualPointFocusableElements = [];

    if (manualPointForm) {
        manualPointForm.reset();
    }

    document.removeEventListener('keydown', manualPointKeydownHandler);

    if (previouslyFocusedElement && typeof previouslyFocusedElement.focus === 'function') {
        previouslyFocusedElement.focus();
    }
    previouslyFocusedElement = null;
}

async function handleManualPointSubmit(event) {
    event.preventDefault();
    if (!manualPointForm) { return; }

    const place = manualPointForm.elements['place_name'].value.trim();
    const date = manualPointForm.elements['start_date'].value;
    const latValue = manualPointForm.elements['latitude'].value.trim();
    const lonValue = manualPointForm.elements['longitude'].value.trim();

    if (!place) {
        showStatus('Place name is required.', true);
        manualPointForm.elements['place_name'].focus();
        return;
    }

    if (!date) {
        showStatus('Date is required.', true);
        manualPointForm.elements['start_date'].focus();
        return;
    }

    if (!latValue) {
        showStatus('Latitude is required.', true);
        manualPointForm.elements['latitude'].focus();
        return;
    }

    const lat = Number(latValue);
    if (!Number.isFinite(lat) || lat < -90 || lat > 90) {
        showStatus('Latitude must be a valid number between -90 and 90.', true);
        manualPointForm.elements['latitude'].focus();
        return;
    }

    if (!lonValue) {
        showStatus('Longitude is required.', true);
        manualPointForm.elements['longitude'].focus();
        return;
    }

    const lon = Number(lonValue);
    if (!Number.isFinite(lon) || lon < -180 || lon > 180) {
        showStatus('Longitude must be a valid number between -180 and 180.', true);
        manualPointForm.elements['longitude'].focus();
        return;
    }

    showLoading();
    try {
        const response = await fetch('/api/add_point', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                place_name: place,
                start_date: date,
                latitude: lat,
                longitude: lon,
                source_type: 'manual'
            })
        });
        const result = await response.json();
        hideLoading();
        showStatus(result.message, result.status === 'error');
        if (result.status === 'success') {
            closeManualPointModal();
            loadMarkers();
        }
    } catch(err) {
        hideLoading();
        showStatus('Error: ' + err.message, true);
    }
}

function addManualPoint() {
    openManualPointModal();
}

function refreshMap() { loadMarkers(); }

document.addEventListener('DOMContentLoaded', async () => {
    setupManualPointModal();
    try {
        const response = await fetch('/api/source_types');
        const types = await response.json();
        const container = document.getElementById('sourceTypeFilters');
        types.forEach(type => {
            const label = document.createElement('label');
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.value = type;
            cb.checked = true;
            cb.addEventListener('change', loadMarkers);
            label.appendChild(cb);
            label.appendChild(document.createTextNode(' ' + type));
            container.appendChild(label);
        });
    } catch(err) {
        console.error('Failed to load source types', err);
    }
    initMap();
    const menu = document.querySelector('.menu-container');
    if (menu) { applyMenuState(menu, menu.classList.contains('open')); }
    document.addEventListener('keydown', (event) => {
        if (event.key !== 'Escape') { return; }
        if (manualPointModal && manualPointModal.classList.contains('open')) { return; }
        const menu = document.querySelector('.menu-container');
        if (menu && menu.classList.contains('open')) {
            event.preventDefault();
            toggleMenu();
            const trigger = menu.querySelector('.menu-toggle');
            if (trigger) { trigger.focus(); }
        }
    });
});

function toggleMenu() {
    const menu = document.querySelector('.menu-container');
    if (!menu) { return; }
    const isOpen = menu.classList.toggle('open');
    applyMenuState(menu, isOpen);
}

function applyMenuState(menu, isOpen) {
    const trigger = menu.querySelector('.menu-toggle');
    const icon = trigger ? trigger.querySelector('.menu-toggle-icon') : null;
    const label = trigger ? trigger.querySelector('.menu-toggle-text') : null;
    const controls = menu.querySelector('.overlay-controls');

    if (trigger) {
        trigger.setAttribute('aria-expanded', String(isOpen));
        trigger.setAttribute('aria-label', isOpen ? 'Close menu' : 'Open menu');
    }
    if (icon) { icon.textContent = isOpen ? '‚úï' : '‚ò∞'; }
    if (label) { label.textContent = isOpen ? 'Close' : 'Menu'; }
    if (controls) {
        controls.setAttribute('aria-hidden', String(!isOpen));
        if (isOpen) { controls.removeAttribute('inert'); }
        else { controls.setAttribute('inert', ''); }
        const focusableSelectors = 'button, [href], input, select, textarea, [tabindex]';
        const focusableElements = controls.querySelectorAll(focusableSelectors);
        focusableElements.forEach((element) => {
            if (isOpen) {
                if (element.dataset.menuPrevTabindex !== undefined) {
                    const previous = element.dataset.menuPrevTabindex;
                    if (previous === '') {
                        element.removeAttribute('tabindex');
                    } else {
                        element.setAttribute('tabindex', previous);
                    }
                    delete element.dataset.menuPrevTabindex;
                } else if (element.getAttribute('tabindex') === '-1') {
                    element.removeAttribute('tabindex');
                }
            } else {
                if (element.dataset.menuPrevTabindex === undefined) {
                    element.dataset.menuPrevTabindex = element.hasAttribute('tabindex') ? element.getAttribute('tabindex') || '' : '';
                }
                element.setAttribute('tabindex', '-1');
            }
        });
    }
}
</script>
</body>
</html>
